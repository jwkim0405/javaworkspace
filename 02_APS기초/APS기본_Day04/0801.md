# String

## 문자의 표현

### 컴퓨터에서의 문자 표현

* 컴퓨터는 모든 데이터를 비트 단위(2진수)로 저장하므로 문자를 직접 저장할 수는 없다.
* 정수의 형태로 문자와 짝지어진 수를 저장하도록 한다.
* 영어 알파벳은 대소문자를 합쳐서 52개이므로 6비트면 모든 알파벳을 표현할 수 있다. 이를 코드체계라고 한다.
    * 과거 미국에서는 지역마다 코드체계가 달랐다.
    * 인터넷이 발전한 후 다른 지역 간 정보를 주고 받으면서 해석하는 내용이 서로 달라지게 되는 문제 발생
    * '표준'을 만들자 !!
* 코드 체계가 달라 발생하는 혼동을 막기 위해 '코드 체계의 표준안'이 만들어졌다.
* 1967년, 미국에서 `ASCII`라는 문자 인코딩 표준이 만들어졌다.

#### 출력 가능한 아스키 문자
| 문자 |아스키코드|
|----|----|
|   0   | 48 |
|   A   | 65 |
|   a   | 97 |

* `확장 아스키`는 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호이다.
    * 표준 아스키는 7bit($2^7 = 128$)를 사용하여 문자를 표현하는 데 비해 확장 아스키는 1Byte 내의 8bit($2^8 = 256$)를 모두 사용함으로써 추가적인 문자를 표현할 수 있다.
    * 컴퓨터 생산자와 소프트웨어 개발자가 여러 가지 다양한 문자를 할당할 수 있도록 하고 있다.
    * 확장 아스키는 표준이 아님 !
* 오늘날 대부분의 컴퓨터는 ASCII 형식의 코드 체계를 사용한다.
* 컴퓨터가 발전하면서 미국 뿐 아니라 세계적으로 컴퓨터가 발전했으며 각 국가들은 자국의 문자를 표현하기 위하여 코드체계를 만들어서 사용하게 되었다.
    * 우리나라도 아주 오래된 이야기지만, 한글 코드체계를 만들어 사요ㅕㅇ했고 조합형, 완성형 두 종류를 가지고 있다.

#### 유니코드
* 인터넷이 전 세계로 발생하면서 ASCII로 만들었을 때의 문제와 같은 문제가 국가 간에 정보를 주고 받을 때 발생했다.
* 자국의 코드 체계를 타 국가가 가지고 있지 않으며 정보를 잘못 해석할 수 밖에 없었다.
* `유니코드` -> 다국어 처리를 위한 표준 !   
* 유니코드도 다시 Character Set으로 분류된다.
    * UCS-2(Universal Character Set 2)
    * UCS-4(Universal Character Set 4)
    * 유니코드를 저장하는 변수의 크기를 정의
    * 그러나, 바이트 순서에 대해서 표준화하지 못했음(`??????`)
    * 다시 말해 파일을 인식 시 이 파일이 UCS-2, UCS-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제 발생
    * 그래서 유니코드의 적당한 외부 인코딩이 필요하게 되었다.
* 유니코드 인코딩(UTF: Unicode Transformation Format)
    * 저장된 코드가 어떤 byte 순서로 저장되었는가
        * UTF-8 (in Web)
        * UTF-16 (in windows, java)
        * UTF-32 (in unix)

## 문자열

### 개념

* 일련의 문자(character)를 담을 수 있는 자료구조
* Java에서는 String class(객체)로 구현되어 있다.

### 문자열을 선언하는 두 가지 방법
| 리터럴(literal) 표기 방식 | new 연산자 사용 방식|
|----|----|
|   String a = "Hello";   | String b = new String("Hello"); |

#### 두 가지 방식의 차이

```java
// 문자열의 초기화

// 1.리터럴 표기 방식
// 힙 영역에서 문자열 상수 pool에 "Hello"가 저장됨.
String lStr1 = "Hello";
String lStr2 = "Hello";

// 2. new 연산자 사용 방식
// 힙 영역에서 각각의 객체가 생성됨.
String str1 = new String("Hello");
String str2 = new String("Hello");		

// == 비교: 주소값 비교
System.out.println(lStr1 == lStr2);	// true
System.out.println(str1 == str2);	// false

// 값 비교
System.out.println(lStr1.equals(lStr2));
System.out.println(str1.equals(str2));
```

### 문자열의 분류
* 문자열
  * fixed length (고정 길이 문자열)
  * variable length (가변 길이 문자열)
    * length controlled (java에서의 문자열)
    * delimited (c언어에서의 문자열)
  

### 문자열의 처리

#### C언어에서의 문자열 처리
* 문자열은 문자들의 배열 형태로 구현된 응용 자료형

```C
char ary[] = {'a', 'b', 'c', '\0'}; // 또는  char ary[] = "abc";
```

#### Java(객체지향 언어)에서의 문자열 처리
* 문자열 데이터를 저장, 처리해주는 클래스를 제공한다.
* String 클래스를 사용한다.

```java
String str = "abc";  // 또는 String str = new String("abc");
```
* 문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공한다.
  * length(), replace(), split(), substring()
  * 보다 풍부한 연산을 제공한다. 

### 문자열 뒤집기

* 문자열 자기 자신 내에서 뒤집는 방법이 있고, 새로운 빈 문자열을 만들어 뒤에서부터 쓰는 방법이 있다.
* 자기 문자열을 이용할 경우는 swap을 위한 임시 변수가 필요하며 반복 수행을 문자 길이의 반만을 수행해야 한다.

### 문자열 숫자를 정수형으로 변환

#### C언어
* atoi()
* 역함수: itoa()

#### Java
* 숫자 클래스의 parse 메소드를 제공한다.
  * Integer.parseInt(String)
  * 역함수: toString()

`오늘의 대발견 1 - Integer class`

* Integer 클래스를 아시나요?
  * `Integer.parseInt()`를 해주면 문자열 형태의 숫자가 숫자로 바뀐답니다.
    * parse가 무슨 뜻일까요? `?!?!?!?!?!?!?!` 
  * `Integer.MIN_VALUE` , `Integer.MAX_VALUE` : 우리가 아주 작은 값, 아주 큰 값으로 초기값을 설정해줘야 한다면! 
  * `그런데 Integer 자료형은 import를 안 해도 되네요???????????`

## 패턴 매칭

### 패턴 매칭에 사용되는 알고리즘들
- 고지식한 패턴 검색 알고리즘
- 카프-라빈 알고리즘
- KMP 알고리즘
- 보이어-무어 알고리즘


#### 고지식한 알고리즘(Brute Force)

* 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작

#### 보이어 무어 알고리즘
* 오른쪽에서 왼쪽으로 비교
* 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
* 보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이만큼 된다.  
